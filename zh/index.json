[{"content":"背景 用于商家积分兑换商品活动 订单送积分 营销送积分 实现 要求 不允许超扣 需要幂等，应对网络问题和重复提交等情况 需要高性能 需要风控，避免薅羊毛 针对锁单需要支持积分预扣 针对退单需要积分回滚 步骤 用户校验 余额校验 用户限额校验（基于redis累加，计算剩余可赠送积分值） 调用存储过程 用户余额校验 加锁（MySQL lock 锁定用户id） 写入积分日志（开启事务） 更新用户余额 其他要求 如何避免超扣 MySQL层面的lock，也有遇到需要超扣的场景，用户一开始就可以使用一定积分，后面再来归还积分。\n如何实现幂等 允许外部传入唯一id，通过redis的不存在写入函数，并且在值记录结果\n值为空（执行中） 值不为空（执行成功） 执行失败清除值 高性能的实现设计 批量提交接口（异步处理） 分库分表（提高单表的并发能力） 幂等（快速成功或者失败） 积分日志同个库设计（避免跨库） tomcat线程数调优（原来200，调整至500） 数据库连接池调优（原来10，调整至20） redis连接池调优（原来200，调整为500） 风控设计 实时检测 允许商家设定每日单用户限额，达到额度后，再赠送积分无效\nredis缓存当前额度 每次扣减前判断额度 需要考虑用户id变更 每日检测 多维度（大额度，日总额度，频率）\n创建钉钉机器人，获取token 配置告警规则，例如通过nick分组查询单日赠送积分总值超过1w的 基于大数据实时检测 Flink+kafka进行监控\n执行环境 创建数据源 用户key分组 ","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E4%BA%8C%E7%A7%AF%E5%88%86%E5%8A%A0%E5%87%8F/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e用于商家积分兑换商品活动\u003c/li\u003e\n\u003cli\u003e订单送积分\u003c/li\u003e\n\u003cli\u003e营销送积分\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"实现\"\u003e实现\u003c/h2\u003e\n\u003ch3 id=\"要求\"\u003e要求\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e不允许超扣\u003c/li\u003e\n\u003cli\u003e需要幂等，应对网络问题和重复提交等情况\u003c/li\u003e\n\u003cli\u003e需要高性能\u003c/li\u003e\n\u003cli\u003e需要风控，避免薅羊毛\u003c/li\u003e\n\u003cli\u003e针对锁单需要支持积分预扣\u003c/li\u003e\n\u003cli\u003e针对退单需要积分回滚\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"步骤\"\u003e步骤\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e用户校验\u003c/li\u003e\n\u003cli\u003e余额校验\u003c/li\u003e\n\u003cli\u003e用户限额校验（基于redis累加，计算剩余可赠送积分值）\u003c/li\u003e\n\u003cli\u003e调用存储过程\n\u003col\u003e\n\u003cli\u003e用户余额校验\u003c/li\u003e\n\u003cli\u003e加锁（MySQL lock 锁定用户id）\u003c/li\u003e\n\u003cli\u003e写入积分日志（开启事务）\u003c/li\u003e\n\u003cli\u003e更新用户余额\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"其他要求\"\u003e其他要求\u003c/h2\u003e\n\u003ch3 id=\"如何避免超扣\"\u003e如何避免超扣\u003c/h3\u003e\n\u003cp\u003eMySQL层面的lock，也有遇到需要超扣的场景，用户一开始就可以使用一定积分，后面再来归还积分。\u003c/p\u003e","title":"积分平台之二[积分加减]"},{"content":"背景 积分过期是一个常见需求，常见的如先进先出模型，另外需要允许客户端传入过期时间\n设计 要求 允许外部定义积分规则（相对时间和绝对时间） 允许外部传入过期时间，如没有传入则默认采用规则计算 过期积分不允许使用 年末海量过期考虑性能 实现 过期积分实现\n积分赠送时，通过外部传参或者计算得到积分过期时间，写入积分赚取明细。积分扣减时，默认按照过期时间、ID排序进行扣减。\n过期规则\n关联商家账号，两种过期类型，默认永久。\n防止过期积分被使用\n用户扣减前执行过期，相当于活跃用户实时保障积分过期。\n定时过期\n每天凌晨1点定时任务，按照表扫描过期积分并执行。\n海量过期\n针对表开启多线程过期，大概可以达到2000每秒的过期效率。\n假设存在两亿条数据需要过期，大概需要一天。\n总结 惰性+活跃用户实时的处理方式，类似redis的缓存过期。\n","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E4%B8%89%E7%A7%AF%E5%88%86%E8%BF%87%E6%9C%9F/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e积分过期是一个常见需求，常见的如先进先出模型，另外需要允许客户端传入过期时间\u003c/p\u003e\n\u003ch2 id=\"设计\"\u003e设计\u003c/h2\u003e\n\u003ch3 id=\"要求\"\u003e要求\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e允许外部定义积分规则（相对时间和绝对时间）\u003c/li\u003e\n\u003cli\u003e允许外部传入过期时间，如没有传入则默认采用规则计算\u003c/li\u003e\n\u003cli\u003e过期积分不允许使用\u003c/li\u003e\n\u003cli\u003e年末海量过期考虑性能\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"实现\"\u003e实现\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e过期积分实现\u003c/p\u003e","title":"积分平台之三[积分过期]"},{"content":"一、业务架构 处理会员积分、账户管理和第三方平台集成。\n1、账户管理 区分普通账号和品牌账号，提供多维度的业务构建基础 按照账号分库分表 2、积分管理 支持多种积分发放场景，单个、批量 支持积分余额查询，明细查询 实现积分风控，每日限额，大额告警 实现积分过期 3、用户管理 用户基本信息查询 用户合并、解绑 用户积分同步 4、第三方模块继承 电商平台会员等级、积分打通 下游品牌打通 二、技术架构 1、整体框架 分层架构：采用经典的控制层、服务层、数据访问层设计\n缓存架构：本地缓存+分布式缓存\n2、基础框架 核心框架：Spring Boot\nORM框架：JFinal\n数据库：MySQL\n缓存：Redis\n连接池：Hikari\n日志框架：logback\n其他工具：Guava、Apache Commons、Hutool\n","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E4%B8%80%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/","summary":"\u003ch2 id=\"一业务架构\"\u003e一、业务架构\u003c/h2\u003e\n\u003cp\u003e处理会员积分、账户管理和第三方平台集成。\u003c/p\u003e\n\u003ch3 id=\"1账户管理\"\u003e1、账户管理\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e区分普通账号和品牌账号，提供多维度的业务构建基础\u003c/li\u003e\n\u003cli\u003e按照账号分库分表\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"2积分管理\"\u003e2、积分管理\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e支持多种积分发放场景，单个、批量\u003c/li\u003e\n\u003cli\u003e支持积分余额查询，明细查询\u003c/li\u003e\n\u003cli\u003e实现积分风控，每日限额，大额告警\u003c/li\u003e\n\u003cli\u003e实现积分过期\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"3用户管理\"\u003e3、用户管理\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e用户基本信息查询\u003c/li\u003e\n\u003cli\u003e用户合并、解绑\u003c/li\u003e\n\u003cli\u003e用户积分同步\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"4第三方模块继承\"\u003e4、第三方模块继承\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e电商平台会员等级、积分打通\u003c/li\u003e\n\u003cli\u003e下游品牌打通\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"二技术架构\"\u003e二、技术架构\u003c/h2\u003e\n\u003ch3 id=\"1整体框架\"\u003e1、整体框架\u003c/h3\u003e\n\u003cp\u003e分层架构：采用经典的控制层、服务层、数据访问层设计\u003c/p\u003e","title":"积分平台之一[整体架构]"},{"content":"背景 原本单个系统的交互中，当客户端需要查找问题时，可以拿着服务端生成的request_id来咨询。\n实现方式：\n定义日志切面，环绕指定基类 生成uuid，放置到日志的mdc 返回给到客户端 在这种实现下，单个系统的问题排查没问题。但是一旦涉及多个系统的交互，一旦出问题，每个环境都要定位一遍请求，设置到问题的流转，人员的流转。\n问题 如何提供一个统一的方式，输入一个request_id即可输出整个链路的请求日志？\n方案 提供SDK，跨服务之间在请求头传递request_id。\n逻辑：没有request_id就生成id，有的话直接获取，request_id绑定threadLocal。\n引出新的问题：\n子线程中无法直接获取request_id，threadLocal与线程绑定。\n1 2 3 4 5 6 7 ThreadLocal\u0026lt;String\u0026gt; threadLocal = new ThreadLocal\u0026lt;\u0026gt;(); threadLocal.set(\u0026#34;123\u0026#34;); System.out.println(threadLocal.get()); new Thread(() -\u0026gt; { System.out.println(threadLocal.get()); // 此处无法获取threadLocal }).start(); 解决：\n使用InheritableThreadLocal可以解决子线程继承数据的问题，但是项目中往往会使用线程池，而线程池中的线程是复用的，这时候InheritableThreadLocal就会导致数据错乱问题，因为InheritableThreadLocal只在线程创建初次复制数据。\n再次解决：\n使用TransmittableThreadLocal，由阿里开源的方案。将数据上下文传递的粒度从线程创建级别调整到任务执行前后，执行前设置，执行后清除。\n总结 跨服务之间通过请求头传递request_id。 由于request_id绑定在线程，在多线程环境下，子线程无法继承父线程的threadLocal。 通过加强版的threadLocal——TransmittableThreadLocal解决线程池中线程的上下文传递和清理 ","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E5%85%A8%E9%93%BE%E8%B7%AFid%E7%9A%84%E5%AE%9E%E7%8E%B0/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e原本单个系统的交互中，当客户端需要查找问题时，可以拿着服务端生成的request_id来咨询。\u003c/p\u003e\n\u003cp\u003e实现方式：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e定义日志切面，环绕指定基类\u003c/li\u003e\n\u003cli\u003e生成uuid，放置到日志的mdc\u003c/li\u003e\n\u003cli\u003e返回给到客户端\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在这种实现下，单个系统的问题排查没问题。但是一旦涉及多个系统的交互，一旦出问题，每个环境都要定位一遍请求，设置到问题的流转，人员的流转。\u003c/p\u003e","title":"全链路id的实现"},{"content":"讲讲MySQL索引的理解 段落2 段落3 1 code ","permalink":"https://yongqiangg.github.io/zh/posts/tech/mysql%E7%B4%A2%E5%BC%95/","summary":"\u003ch1 id=\"讲讲mysql索引的理解\"\u003e讲讲MySQL索引的理解\u003c/h1\u003e\n\u003ch2 id=\"段落2\"\u003e段落2\u003c/h2\u003e\n\u003ch3 id=\"段落3\"\u003e段落3\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecode\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"MySQL索引"}]