[{"content":"背景 排查问题，系统之间往往需要定位到同一个链路请求，因此需要链路追踪。\n另外一些实时业务需要针对性监控时效性，并告警通知。\n设计 要求 需要提供全链路追踪id 需要监控同步进度 实现 版本一\n不跨系统的请求id，直接拦截器为请求生成uuid，并返回给到客户端，同时写到日志。\n版本二\n请求头获取请求id，不存在则生成 跨系统之间通过请求头传输 通过threadlocal绑定线程获取请求id，线程池时需要考虑线程复用和父子线程数据复制，使用阿里的开源threadlocal 告警\n通过提交sql，判断时间差值，并钉钉告警（数据库定时任务） redis队列监控，定时获取队列长度 mq消息监控，通过消费组查询队列积压告警 扩展 threadLocal内存泄漏问题\n一般使用threadLocal需要手动调用一下remove确保清除内存。\n不然可能造成值内存泄漏，threalocal设计是一个类似map的结构，key和val都需要内存回收，如果val没有被置为null，可能在一些线程池场景，可达性分析还能追溯到引用链，造成无法回收内存。\n","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E5%85%AB%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E4%B8%8E%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e排查问题，系统之间往往需要定位到同一个链路请求，因此需要链路追踪。\u003c/p\u003e\n\u003cp\u003e另外一些实时业务需要针对性监控时效性，并告警通知。\u003c/p\u003e\n\u003ch2 id=\"设计\"\u003e设计\u003c/h2\u003e\n\u003ch3 id=\"要求\"\u003e要求\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e需要提供全链路追踪id\u003c/li\u003e\n\u003cli\u003e需要监控同步进度\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"实现\"\u003e实现\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e版本一\u003c/p\u003e","title":"积分平台之八[链路追踪与监控告警]"},{"content":"背景 用于商家积分兑换商品活动 订单送积分 营销送积分 实现 要求 不允许超扣 需要幂等，应对网络问题和重复提交等情况 需要高性能 需要风控，避免薅羊毛 针对锁单需要支持积分预扣 针对退单需要积分回滚 步骤 用户校验 余额校验 用户限额校验（基于redis累加，计算剩余可赠送积分值） 调用存储过程 用户余额校验 加锁（MySQL lock 锁定用户id） 写入积分日志（开启事务） 更新用户余额 其他要求 如何避免超扣 MySQL层面的lock，也有遇到需要超扣的场景，用户一开始就可以使用一定积分，后面再来归还积分。\n如何实现幂等 允许外部传入唯一id，通过redis的不存在写入函数，并且在值记录结果\n值为空（执行中） 值不为空（执行成功） 执行失败清除值 高性能的实现设计 批量提交接口（异步处理） 分库分表（提高单表的并发能力） 幂等（快速成功或者失败） 积分日志同个库设计（避免跨库） tomcat线程数调优（原来200，调整至500） 数据库连接池调优（原来10，调整至20） redis连接池调优（原来200，调整为500） 风控设计 实时检测 允许商家设定每日单用户限额，达到额度后，再赠送积分无效\nredis缓存当前额度 每次扣减前判断额度 需要考虑用户id变更 每日检测 多维度（大额度，日总额度，频率）\n创建钉钉机器人，获取token 配置告警规则，例如通过nick分组查询单日赠送积分总值超过1w的 基于大数据实时检测 Flink+kafka进行监控\n执行环境 创建数据源 用户key分组 ","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E4%BA%8C%E7%A7%AF%E5%88%86%E5%8A%A0%E5%87%8F/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e用于商家积分兑换商品活动\u003c/li\u003e\n\u003cli\u003e订单送积分\u003c/li\u003e\n\u003cli\u003e营销送积分\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"实现\"\u003e实现\u003c/h2\u003e\n\u003ch3 id=\"要求\"\u003e要求\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e不允许超扣\u003c/li\u003e\n\u003cli\u003e需要幂等，应对网络问题和重复提交等情况\u003c/li\u003e\n\u003cli\u003e需要高性能\u003c/li\u003e\n\u003cli\u003e需要风控，避免薅羊毛\u003c/li\u003e\n\u003cli\u003e针对锁单需要支持积分预扣\u003c/li\u003e\n\u003cli\u003e针对退单需要积分回滚\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"步骤\"\u003e步骤\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e用户校验\u003c/li\u003e\n\u003cli\u003e余额校验\u003c/li\u003e\n\u003cli\u003e用户限额校验（基于redis累加，计算剩余可赠送积分值）\u003c/li\u003e\n\u003cli\u003e调用存储过程\n\u003col\u003e\n\u003cli\u003e用户余额校验\u003c/li\u003e\n\u003cli\u003e加锁（MySQL lock 锁定用户id）\u003c/li\u003e\n\u003cli\u003e写入积分日志（开启事务）\u003c/li\u003e\n\u003cli\u003e更新用户余额\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"其他要求\"\u003e其他要求\u003c/h2\u003e\n\u003ch3 id=\"如何避免超扣\"\u003e如何避免超扣\u003c/h3\u003e\n\u003cp\u003eMySQL层面的lock，也有遇到需要超扣的场景，用户一开始就可以使用一定积分，后面再来归还积分。\u003c/p\u003e","title":"积分平台之二[积分加减]"},{"content":"背景 应用的接口往往需要多重的鉴权保证生产环境的安全，防止攻击\n例子 ip维度\n配置ip白名单，限制访问ip\n可信服务名\n由于主要是对内部上游的业务平台，配置对应的可信服务名，允许跳过ip直接访问\napp维度\n对于非平台接口，校验应用的app和appSecret，生成签名需要使用appSecret\n账号维度\n对于账号，需要校验token\n时间维度\n对于内部请求，需要判断请求是否已经超过10秒\n平台请求\n一般两边按照固定的签名算法，对参数进行排序结合app信息进行验签\n","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E4%BA%8C%E5%8D%81%E5%BA%94%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e应用的接口往往需要多重的鉴权保证生产环境的安全，防止攻击\u003c/p\u003e\n\u003ch2 id=\"例子\"\u003e例子\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eip维度\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e配置ip白名单，限制访问ip\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e可信服务名\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e由于主要是对内部上游的业务平台，配置对应的可信服务名，允许跳过ip直接访问\u003c/p\u003e","title":"积分平台之二十[应用接口安全]"},{"content":"背景 工程项目需要持续的构建-发布能力\n实现 持续构建\nTeamCity。\n区分环境进行构建 可以构建代码包及镜像形式 可以配置触发器，代码提交时自动触发构建 发布\n聚石塔 or 阿里云k8s集群版\n分支管理\nmaster：对应生产环境，受保护，不允许提交\ndev：测试环境分支，受保护，不允许提交\n功能分支从master拉取，开发完成后，合并到dev进行验证\n注意 需要配置保留的最近版本数量，避免空间持续占用\n","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E4%B9%9Dcicd/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e工程项目需要持续的构建-发布能力\u003c/p\u003e\n\u003ch2 id=\"实现\"\u003e实现\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e持续构建\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eTeamCity。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e区分环境进行构建\u003c/li\u003e\n\u003cli\u003e可以构建代码包及镜像形式\u003c/li\u003e\n\u003cli\u003e可以配置触发器，代码提交时自动触发构建\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e发布\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e聚石塔 or 阿里云k8s集群版\u003c/p\u003e","title":"积分平台之九[CI/CD]"},{"content":"背景 当遇到如下场景需要考虑限流以保护整个系统不发生宕机\n暴露给品牌方接口，可能存在突发流量 大促时，暴露给平台端的接口，可以由于品牌或者平台的活动，接收到大量的c端流量 设计 要求 关键接口尽可能高性能 当发生高频请求时，告警通知 限流组件 支持动态限流 实现 实例环境隔离，区分开平台流量和品牌流量，通过请求头方式隔离大查询（慢sql风险） 统计网关层的tp99并对接钉钉告警，业务日志需要包含请求耗时 限流组件使用sentinel 结合guava封装限流注解实现单机限流 扩展 常见限流算法\n漏桶 令牌桶，guava的rateLimiter，应对突发流量 滑动窗口，sentinel sentinel使用\n配置规则，指定流控规则（qps或并发线程数），指定限流参数，指定按照参数独立限流 加载规则 添加注解和降级规则 限流注解封装\n定义限流注解，包含令牌数，限流key可以直接采用方法名字，返回结果json 编写限流切面，按照注解切入，获取令牌，获取失败返回特定错误码 编写自动配置类 编写spring.factories 引入starter并使用 ","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E5%85%AD%E9%99%90%E6%B5%81/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e当遇到如下场景需要考虑限流以保护整个系统不发生宕机\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e暴露给品牌方接口，可能存在突发流量\u003c/li\u003e\n\u003cli\u003e大促时，暴露给平台端的接口，可以由于品牌或者平台的活动，接收到大量的c端流量\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"设计\"\u003e设计\u003c/h2\u003e\n\u003ch3 id=\"要求\"\u003e要求\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e关键接口尽可能高性能\u003c/li\u003e\n\u003cli\u003e当发生高频请求时，告警通知\u003c/li\u003e\n\u003cli\u003e限流组件\u003c/li\u003e\n\u003cli\u003e支持动态限流\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"实现\"\u003e实现\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e实例环境隔离，区分开平台流量和品牌流量，通过请求头方式隔离大查询（慢sql风险）\u003c/li\u003e\n\u003cli\u003e统计网关层的tp99并对接钉钉告警，业务日志需要包含请求耗时\u003c/li\u003e\n\u003cli\u003e限流组件使用sentinel\u003c/li\u003e\n\u003cli\u003e结合guava封装限流注解实现单机限流\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"扩展\"\u003e扩展\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e常见限流算法\u003c/p\u003e","title":"积分平台之六[限流]"},{"content":"背景 积分回滚\n针对特定的积分操作回滚，避免用户使用回滚刷新积分有效期。例如积分加钱购买商品。\n之前发生退单时，需要重新赠送积分，会导致原来使用的积分重置有效期。\n积分冻结\n有的平台用户消耗积分需要先冻结，在确认使用或者取消，两阶段。\n如果直接采用积分加减操作，再逆向操作，会产生两笔积分日志。\n设计 要求 积分回滚需要支持特定积分回滚，过期时间不刷新 赠送的回滚，需要优先扣减同一笔赠送，再差值补齐 扣减的回滚，需要回滚每一笔当时扣减的积分和有效期 积分冻结后，支持按照唯一标识进行实际扣减或者取消扣减 实现 赠送积分回滚\n限制特定业务类型支持回滚 回滚记录到明细表 回滚时优先扣减特定记录，可能已经被使用 再走正常扣减，产生多条记录 扣减回滚\n限制特定业务支持回滚 扣减记录到回滚明细，包含具体扣减的guid、积分值、过期时间 回滚时赠送积分，并按照具体的回滚记录还原明细 冻结积分\n扣减时不产生日志，但是更新用户积分值，并记录预扣记录。\n冻结最长时效1天，一天后自动返还，由定时任务处理。\n实际扣减\n按照预扣记录积分值执行扣减，删除预扣记录\n取消预扣\n更新用户积分值，删除预扣记录\n","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E4%B8%83%E7%A7%AF%E5%88%86%E5%9B%9E%E6%BB%9A%E4%B8%8E%E7%A7%AF%E5%88%86%E5%86%BB%E7%BB%93/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e积分回滚\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e针对特定的积分操作回滚，避免用户使用回滚刷新积分有效期。例如积分加钱购买商品。\u003c/p\u003e\n\u003cp\u003e之前发生退单时，需要重新赠送积分，会导致原来使用的积分重置有效期。\u003c/p\u003e","title":"积分平台之七[积分回滚和积分冻结]"},{"content":"背景 积分过期是一个常见需求，常见的如先进先出模型，另外需要允许客户端传入过期时间\n设计 要求 允许外部定义积分规则（相对时间和绝对时间） 允许外部传入过期时间，如没有传入则默认采用规则计算 过期积分不允许使用 年末海量过期考虑性能 实现 过期积分实现\n积分赠送时，通过外部传参或者计算得到积分过期时间，写入积分赚取明细。积分扣减时，默认按照过期时间、ID排序进行扣减。\n过期规则\n关联商家账号，两种过期类型，默认永久。\n防止过期积分被使用\n用户扣减前执行过期，相当于活跃用户实时保障积分过期。\n定时过期\n每天凌晨1点定时任务，按照表扫描过期积分并执行。\n海量过期\n针对表开启多线程过期，大概可以达到2000每秒的过期效率。\n假设存在两亿条数据需要过期，大概需要一天。\n总结 惰性+活跃用户实时的处理方式，类似redis的缓存过期。\n","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E4%B8%89%E7%A7%AF%E5%88%86%E8%BF%87%E6%9C%9F/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e积分过期是一个常见需求，常见的如先进先出模型，另外需要允许客户端传入过期时间\u003c/p\u003e\n\u003ch2 id=\"设计\"\u003e设计\u003c/h2\u003e\n\u003ch3 id=\"要求\"\u003e要求\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e允许外部定义积分规则（相对时间和绝对时间）\u003c/li\u003e\n\u003cli\u003e允许外部传入过期时间，如没有传入则默认采用规则计算\u003c/li\u003e\n\u003cli\u003e过期积分不允许使用\u003c/li\u003e\n\u003cli\u003e年末海量过期考虑性能\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"实现\"\u003e实现\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e过期积分实现\u003c/p\u003e","title":"积分平台之三[积分过期]"},{"content":"背景 什么情况下需要分库分表\n数据量比较大，不要遇到数据库问题就考虑分库分表，优先考虑软件和硬件的优化。\n由于数据量较大，整体会达到几十个T。因此按照租户进行分库分表。\n设计 要求 按照租户进行分库分表 最好sql无侵入 特定大租户可以单独指定 实现 阿里索引表方案 索引表维护库表关系 创建租户账号时分配库表，写入到数据库，加载到缓存。（分配可以采用列表索引自增，后序扩容可以采用列表项概率不均来制造倾斜） 数据库层调用通过threadlocal传递库表编号数据，分表编号拼接到sql，分库标号获取数据源，完成组装 会侵入sql\nApache ShardingSphere方案 确定分片键 编写表策略，根据分片键查询，优先查询redis 编写库策略，根据分片键查询，优先查询redis 使用mybatis 使用精准分片算法。结合mybatis，无sql侵入\n扩展 额外封装一个数据路由starter，外部传入数据源，封装分片键和算法\n扩容过程 更新库表索引关系 迁移旧表数据，使用阿里dts数据实时同步工具将旧表同步到新库 更新租户表对应的库表 更新缓存，路由到新库 ","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E5%8D%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e什么情况下需要分库分表\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e数据量比较大，不要遇到数据库问题就考虑分库分表，优先考虑软件和硬件的优化。\u003c/p\u003e\n\u003cp\u003e由于数据量较大，整体会达到几十个T。因此按照租户进行分库分表。\u003c/p\u003e","title":"积分平台之十[分库分表]"},{"content":"背景 使用过的微服务组件\n例子 网关\nSpring Gateway，用于路由。由于平台限制流量不允许直接出服务器，因此需要部署中间网关对流量进行转发。包含上行和下行的流量，拦截指定路径，并对路径进行重写即可\n限流\nsentinel，定义限流规则，按照租户进行限流控制。例如单个接口单个租户上限为100qps。\n配置服务端地址 定义规则，指定租户参数，限流策略 添加注解，指定资源和降级策略 中心配置\nnacos，用于动态参数配置\n配置nacos服务端，配置namespace 项目内使用注解，冒号后配置默认值 远程调用\nopenfeign，声明式\n定义接口，注解定义请求方式和路径，入参和出参 ","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E5%8D%81%E5%85%AB%E5%BE%AE%E6%9C%8D%E5%8A%A1/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e使用过的微服务组件\u003c/p\u003e\n\u003ch2 id=\"例子\"\u003e例子\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e网关\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eSpring Gateway，用于路由。由于平台限制流量不允许直接出服务器，因此需要部署中间网关对流量进行转发。包含上行和下行的流量，拦截指定路径，并对路径进行重写即可\u003c/p\u003e","title":"积分平台之十八[微服务组件]"},{"content":"背景 第三方客户往往容易存在调用失败的问题，在关键链路上如何应对这种问题。尤其是大促期间可能的调用超时，该如何处理。\n例如兑换礼品，调用后超时，如果只是简单的发起重试，容易造成业务的异常。\n设计 要求 遇到超时的正确处理 实现 识别超时异常 写入中间表 定时任务扫描中间表，进行二次确认（需要第三方提供查询接口，通过流水号） 如果之前为失败，那么发起重试，更新重试次数和下次重试时间 需要限制重试次数，例如超过三次标记为彻底失败，人工介入 ","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E5%8D%81%E4%BA%8C%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e第三方客户往往容易存在调用失败的问题，在关键链路上如何应对这种问题。尤其是大促期间可能的调用超时，该如何处理。\u003c/p\u003e\n\u003cp\u003e例如兑换礼品，调用后超时，如果只是简单的发起重试，容易造成业务的异常。\u003c/p\u003e","title":"积分平台之十二[第三方网络问题]"},{"content":"背景 数据库死锁常发生于两个事务，互相依赖对方的资源，在获取锁的时候形成互相等待。MySQL会自动检测死锁，并回滚较小的事务。\n例子 在用户查询积分的时候，触发了过期。\n积分过期处理步骤如下：\n查询需要过期的积分总值 更新用户的可用积分 查询需要过期的积分 删除对应的积分 ABA的步骤形成了不同顺序的锁访问，而这个触发点又埋在查询接口，很容易出现同时多个请求同一个用户的查询。\n处理方案 破坏掉这个不同顺序，查询过期积分同时查出id，这样就不会后续再查询一遍导致等待。\n","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E5%8D%81%E4%B9%9D%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e数据库死锁常发生于两个事务，互相依赖对方的资源，在获取锁的时候形成互相等待。MySQL会自动检测死锁，并回滚较小的事务。\u003c/p\u003e\n\u003ch3 id=\"例子\"\u003e例子\u003c/h3\u003e\n\u003cp\u003e在用户查询积分的时候，触发了过期。\u003c/p\u003e","title":"积分平台之十九[数据库死锁]"},{"content":"背景 项目中的cpu使用率往往不高，使用多线程可以迅速提高cpu利用率，迅速提高任务处理效率。\n例子 任务中的多线程设计\n使用countdownLatch，将人群进行拆分，多线程进行处理，然后主线程阻塞等待下一批任务 使用最大线程数控制，原子类，判断线程数进行多线程开启，否则sleep，不占用cpu 接口中的多线程设计\n使用jdk7的completeable并发请求，然后汇总结果，可以自定义线程池，默认任务队列int的max值，需要小心。\n对线程池参数的理解\ncore：核心线程数\nmax：最大线程数，当队列满时才开始生效\n任务队列：列表数组，链表数组，链表数据性能更加，两把锁，拿任务和塞任务不冲突\n拒绝策略：当队列满切最大线程满，触发拒绝策略，一般有主线程处理，拒绝任务，抛弃旧的任务，抛弃新的任务\n封装动态线程池\n采用starter机制，由项目引入管理线程池。\n采用redis作为注册中心，将线程池按照项目名称注册到redis 前端界面提交修改线程参数，消费消息更新线程池 定时任务更新队列任务到redis 前端查询直接查询redis信息 ","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E5%8D%81%E5%85%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e项目中的cpu使用率往往不高，使用多线程可以迅速提高cpu利用率，迅速提高任务处理效率。\u003c/p\u003e\n\u003ch2 id=\"例子\"\u003e例子\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e任务中的多线程设计\u003c/p\u003e\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e使用countdownLatch，将人群进行拆分，多线程进行处理，然后主线程阻塞等待下一批任务\u003c/li\u003e\n\u003cli\u003e使用最大线程数控制，原子类，判断线程数进行多线程开启，否则sleep，不占用cpu\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e接口中的多线程设计\u003c/p\u003e","title":"积分平台之十六[多线程使用]"},{"content":"背景 消息队列是现代应用系统中应用非常广泛的组件。可以利用消息队列实现流量削峰，业务解耦。\n例子 流量削峰\n用户入会。大促时，往往会出现大量的用户引流入会，这时候快速的处理入会请求，不影响用户的活动参与就非常重要。这时候往往将用户入会请求直接标记为成功，再交由消费服务完成完整的入会过程，可能涉及历史的积分等级处理。\n业务解耦\n在用户积分等级更新链路上，往往容易出现大促的高流量。这时候链路中如果还存在用户创建等重操作，往往导致接口的qps无法提高，并且导致数据库压力骤增。这时候就要将非核心业务进行剥离，例如用户创建不影响更新动作异步处理。\n如何保证消息不丢\n生产端需要保障可靠性投递，例如与业务封装在同一个事务中，保证业务成功消息一定落库。\n再由服务进行扫描消息投递消息，这时候可以保证消息投递成功。\n消费端，消费到消息后保证业务成功后再进行ack，业务如果失败，同样落库，再由补偿服务进行重试。\n消费顺序问题\n对接会员状态变更消息时，由于无法保证消费顺序，导致用户最终状态不一致。\n这时候需要使用顺序队列，改造生产端将用户id hash到相同的队列key，消费端同样需要按照队列key顺序处理，保证顺序一致。\n另外也可以采用时间戳丢弃历史消息，但是需要保证落库可追溯。业务允许，且出现概率不高可以这样处理节省费用。\n消息积压怎么处理\n入会送积分，挤压了50w。调整服务处理为多线程，另外开启多个消费实例进行处理，成功在半小时之内完成处理。\n","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E5%8D%81%E4%B8%83%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e消息队列是现代应用系统中应用非常广泛的组件。可以利用消息队列实现流量削峰，业务解耦。\u003c/p\u003e\n\u003ch2 id=\"例子\"\u003e例子\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e流量削峰\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e用户入会。大促时，往往会出现大量的用户引流入会，这时候快速的处理入会请求，不影响用户的活动参与就非常重要。这时候往往将用户入会请求直接标记为成功，再交由消费服务完成完整的入会过程，可能涉及历史的积分等级处理。\u003c/p\u003e","title":"积分平台之十七[消息队列]"},{"content":"背景 很多系统中往往需要一个全局唯一的id，例如订单号，用户id。\n现在在积分日志分库分表情况下需要唯一id。数据异构之间的同步，如果不是唯一id，可能发生冲突。\n设计 要求 唯一id 最好单调递增（对MySQL页面存储有利，避免频繁页分裂） 最好用数字，节省空间 实现 版本一\n采用唯一记录行记录id，每次获取id，先获取再更新。\n存在性能瓶颈，取决于单行数据的更新tps，数据库连接存在瓶颈。\n版本二\n原来每次获取1个id，现在每次获取一段id。\n采用乐观锁更新，考虑更新频率不算高。\n并且加载一段id后，当使用到一半，由异步线程更新下一段。\n数据库设计：当前值，每段大小，步长\n总结 成功将分布式id的性能提高50%以上，只需要在内存中获取。并且同步异步加载第二段，消除加载过程中的耗时。\n竞争状态下的并发安全由乐观锁控制，先读取后更新，发现更新失败重新读取。\n","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E5%8D%81%E4%B8%89%E5%88%86%E5%B8%83%E5%BC%8Fid/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e很多系统中往往需要一个全局唯一的id，例如订单号，用户id。\u003c/p\u003e\n\u003cp\u003e现在在积分日志分库分表情况下需要唯一id。数据异构之间的同步，如果不是唯一id，可能发生冲突。\u003c/p\u003e","title":"积分平台之十三[分布式id]"},{"content":"背景 线上问题排查是一名合格开发的必备技能。\n设计 要求 线上出现慢接口，如何定位问题 任务无法启动，频繁重启，如何定位，例如淘宝同步服务 应对 arthas 通过阿里开源诊断工具arthas可以进行处理\n拉取arthas jar包 启动arthas 加载到对应的jvm进程 全局\ndashboard可以看到jvm信息，内存信息，gc信息，线程信息\n慢接口\ntrace命令，后面跟方法的全限定名字，可以过滤耗时大于3000毫秒的。清晰看到耗时的方法，比如慢sql\n异常空指针\nwatch命令，可以看完整的入参、出参、异常信息\n代码不一致\njad可以反编译代码\n内存分析工具mat 启动命令加入内存异常时生成堆内存信息，拿到mat分析。\n例如可以看到http连接没有正常关闭释放资源。\n扩展 淘宝用户同步服务\n采用了6g还是同步内存溢出，商家过多，线程启动多，也占据内存空间。按组拆分部署。\n","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E5%8D%81%E5%9B%9B%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e线上问题排查是一名合格开发的必备技能。\u003c/p\u003e\n\u003ch2 id=\"设计\"\u003e设计\u003c/h2\u003e\n\u003ch3 id=\"要求\"\u003e要求\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e线上出现慢接口，如何定位问题\u003c/li\u003e\n\u003cli\u003e任务无法启动，频繁重启，如何定位，例如淘宝同步服务\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"应对\"\u003e应对\u003c/h3\u003e\n\u003ch4 id=\"arthas\"\u003earthas\u003c/h4\u003e\n\u003cp\u003e通过阿里开源诊断工具arthas可以进行处理\u003c/p\u003e","title":"积分平台之十四[线上问题排查]"},{"content":"背景 数据库作为项目核心组件，常见的问题分析和优化\n例子 积分日志查询慢\n数据密度大，遇到深翻页问题，采用返回id进行数据过滤，需要客户端配合调整。\n进一步，采用推模型来同步积分日志。\n用户信息查询\n跨表join采用了select *，其实只需要两三个字段，覆盖索引即可。\n服务处理日志写入\n单条写入，采用队列缓冲，批量写入\n没有选择正确的索引\n强制索引\n最左匹配无法生效\n采用union all，避免采用union，需要建临时表去重\n网络耗时\n查询用户的可用积分明细，可能很多数据量\n字符集不一致\n导致join索引失效\n","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E5%8D%81%E4%BA%94%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e数据库作为项目核心组件，常见的问题分析和优化\u003c/p\u003e\n\u003ch2 id=\"例子\"\u003e例子\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e积分日志查询慢\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e数据密度大，遇到深翻页问题，采用返回id进行数据过滤，需要客户端配合调整。\u003c/p\u003e\n\u003cp\u003e进一步，采用推模型来同步积分日志。\u003c/p\u003e","title":"积分平台之十五[数据库优化相关]"},{"content":"背景 不断增长的存储空间占用，需要降低存储，清理无效账号\n设计 要求 按照租户进行归档，挑选近三年没有积分日志新增且用户最大更新时间为三年前的租户 归档前需要确认 使用oss存储，支持还原 实现 按照租户进行筛选 进行二次运营确认 确认归档处理，按照数据行复制到文件后进行gzip压缩 上传到oss 删除数据（注意在业务低峰期） 如果需要还原，从oss下载文件解压，并导入 ","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E5%8D%81%E4%B8%80%E8%B4%A6%E5%8F%B7%E5%BD%92%E6%A1%A3/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e不断增长的存储空间占用，需要降低存储，清理无效账号\u003c/p\u003e\n\u003ch2 id=\"设计\"\u003e设计\u003c/h2\u003e\n\u003ch3 id=\"要求\"\u003e要求\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e按照租户进行归档，挑选近三年没有积分日志新增且用户最大更新时间为三年前的租户\u003c/li\u003e\n\u003cli\u003e归档前需要确认\u003c/li\u003e\n\u003cli\u003e使用oss存储，支持还原\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"实现\"\u003e实现\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e按照租户进行筛选\u003c/li\u003e\n\u003cli\u003e进行二次运营确认\u003c/li\u003e\n\u003cli\u003e确认归档处理，按照数据行复制到文件后进行gzip压缩\u003c/li\u003e\n\u003cli\u003e上传到oss\u003c/li\u003e\n\u003cli\u003e删除数据（注意在业务低峰期）\u003c/li\u003e\n\u003cli\u003e如果需要还原，从oss下载文件解压，并导入\u003c/li\u003e\n\u003c/ol\u003e","title":"积分平台之十一[账号归档]"},{"content":"背景 积分相当于用户的资产，往往需要当作金钱对待\n设计 要求 需要及时发现用户的薅羊毛行为 对于异常用户需要有黑名单机制 接口调用需要有相应的鉴权措施 实现 如何及时发现用户的薅羊毛行为\n通过日志对用户积分使用频率、额度进行统计监控\n如何预防\n对每日额度进行限制，要求必须高性能\n版本一：通过lua脚本实现，计算用户的每日额度，维护性较差，性能较高\n版本二：直接通过多条redis命令实现\n黑名单如何实现\n如何拉黑用户\n提供拉黑接口 拉黑时将用户昵称信息全部插入黑名单表 同时加载到缓存 如何判断拉黑\n封装对应的方法级注解，拦截业务参数，在缓存中进行判断。\n扩展 动态代理 目的：在不修改原始类代码的前提下，通过代理对象控制对目标对象的访问。\n定义接口和实现类 实现invocationHandler 生成代理对象并调用方法 1 2 3 4 5 6 7 8 9 10 11 public class Main { public static void main(String[] args) { UserService target = new UserServiceImpl(); UserService proxy = (UserService) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new LogInvocationHandler(target) ); proxy.saveUser(\u0026#34;张三\u0026#34;); // 输出增强后的日志 } } 有接口优先使用JDK自带，性能较好，依赖反射实现。\n没有接口再使用cglib，通过ASM库生成目标类的子类，覆盖父类方法。\n总结 可以进一步优化实现实时风控，通过flink+kafka实现实时的用户检测。\n","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E5%9B%9B%E9%A3%8E%E6%8E%A7%E4%B8%8E%E5%AE%89%E5%85%A8/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e积分相当于用户的资产，往往需要当作金钱对待\u003c/p\u003e\n\u003ch2 id=\"设计\"\u003e设计\u003c/h2\u003e\n\u003ch3 id=\"要求\"\u003e要求\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e需要及时发现用户的薅羊毛行为\u003c/li\u003e\n\u003cli\u003e对于异常用户需要有黑名单机制\u003c/li\u003e\n\u003cli\u003e接口调用需要有相应的鉴权措施\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"实现\"\u003e实现\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e如何及时发现用户的薅羊毛行为\u003c/p\u003e","title":"积分平台之四[风控与安全]"},{"content":"背景 作为一套积分系统，数据一致性相当重要。例如积分日志和积分总值的对账一致。\n设计 要求 积分日志和积分总值对得上 支持按照积分日志回放积分值 支持按照业务系统、活动进行对账 实现 自身对账\n写入积分日志和积分总值在同一个事务，同时利用日志同步进行读写分离和避免跨库事务。\n幂等保障当网络异常超时时，客户端重复提交请求，保证至多一次成功。\n跨系统对账\n积分日志额外存储，按照业务系统、活动id存储。\n修复数据\n提供运维工具，当发生数据异常时可以支持按照积分日志回放用户的积分总值和赚取积分明细。\n总结 由数据库事务来保证一致性，另外支持数据恢复\n","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E4%BA%94%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e作为一套积分系统，数据一致性相当重要。例如积分日志和积分总值的对账一致。\u003c/p\u003e\n\u003ch2 id=\"设计\"\u003e设计\u003c/h2\u003e\n\u003ch3 id=\"要求\"\u003e要求\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e积分日志和积分总值对得上\u003c/li\u003e\n\u003cli\u003e支持按照积分日志回放积分值\u003c/li\u003e\n\u003cli\u003e支持按照业务系统、活动进行对账\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"实现\"\u003e实现\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e自身对账\u003c/p\u003e","title":"积分平台之五[数据一致性]"},{"content":"一、业务架构 处理会员积分、账户管理和第三方平台集成。\n1、账户管理 区分普通账号和品牌账号，提供多维度的业务构建基础 按照账号分库分表 2、积分管理 支持多种积分发放场景，单个、批量 支持积分余额查询，明细查询 实现积分风控，每日限额，大额告警 实现积分过期 3、用户管理 用户基本信息查询 用户合并、解绑 用户积分同步 4、第三方模块继承 电商平台会员等级、积分打通 下游品牌打通 二、技术架构 1、整体框架 分层架构：采用经典的控制层、服务层、数据访问层设计\n缓存架构：本地缓存+分布式缓存\n2、基础框架 核心框架：Spring Boot\nORM框架：JFinal\n数据库：MySQL\n缓存：Redis\n连接池：Hikari\n日志框架：logback\n其他工具：Guava、Apache Commons、Hutool\n","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E7%A7%AF%E5%88%86%E5%B9%B3%E5%8F%B0%E4%B9%8B%E4%B8%80%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/","summary":"\u003ch2 id=\"一业务架构\"\u003e一、业务架构\u003c/h2\u003e\n\u003cp\u003e处理会员积分、账户管理和第三方平台集成。\u003c/p\u003e\n\u003ch3 id=\"1账户管理\"\u003e1、账户管理\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e区分普通账号和品牌账号，提供多维度的业务构建基础\u003c/li\u003e\n\u003cli\u003e按照账号分库分表\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"2积分管理\"\u003e2、积分管理\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e支持多种积分发放场景，单个、批量\u003c/li\u003e\n\u003cli\u003e支持积分余额查询，明细查询\u003c/li\u003e\n\u003cli\u003e实现积分风控，每日限额，大额告警\u003c/li\u003e\n\u003cli\u003e实现积分过期\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"3用户管理\"\u003e3、用户管理\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e用户基本信息查询\u003c/li\u003e\n\u003cli\u003e用户合并、解绑\u003c/li\u003e\n\u003cli\u003e用户积分同步\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"4第三方模块继承\"\u003e4、第三方模块继承\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e电商平台会员等级、积分打通\u003c/li\u003e\n\u003cli\u003e下游品牌打通\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"二技术架构\"\u003e二、技术架构\u003c/h2\u003e\n\u003ch3 id=\"1整体框架\"\u003e1、整体框架\u003c/h3\u003e\n\u003cp\u003e分层架构：采用经典的控制层、服务层、数据访问层设计\u003c/p\u003e","title":"积分平台之一[整体架构]"},{"content":"背景 原本单个系统的交互中，当客户端需要查找问题时，可以拿着服务端生成的request_id来咨询。\n实现方式：\n定义日志切面，环绕指定基类 生成uuid，放置到日志的mdc 返回给到客户端 在这种实现下，单个系统的问题排查没问题。但是一旦涉及多个系统的交互，一旦出问题，每个环境都要定位一遍请求，设置到问题的流转，人员的流转。\n问题 如何提供一个统一的方式，输入一个request_id即可输出整个链路的请求日志？\n方案 提供SDK，跨服务之间在请求头传递request_id。\n逻辑：没有request_id就生成id，有的话直接获取，request_id绑定threadLocal。\n引出新的问题：\n子线程中无法直接获取request_id，threadLocal与线程绑定。\n1 2 3 4 5 6 7 ThreadLocal\u0026lt;String\u0026gt; threadLocal = new ThreadLocal\u0026lt;\u0026gt;(); threadLocal.set(\u0026#34;123\u0026#34;); System.out.println(threadLocal.get()); new Thread(() -\u0026gt; { System.out.println(threadLocal.get()); // 此处无法获取threadLocal }).start(); 解决：\n使用InheritableThreadLocal可以解决子线程继承数据的问题，但是项目中往往会使用线程池，而线程池中的线程是复用的，这时候InheritableThreadLocal就会导致数据错乱问题，因为InheritableThreadLocal只在线程创建初次复制数据。\n再次解决：\n使用TransmittableThreadLocal，由阿里开源的方案。将数据上下文传递的粒度从线程创建级别调整到任务执行前后，执行前设置，执行后清除。\n总结 跨服务之间通过请求头传递request_id。 由于request_id绑定在线程，在多线程环境下，子线程无法继承父线程的threadLocal。 通过加强版的threadLocal——TransmittableThreadLocal解决线程池中线程的上下文传递和清理 ","permalink":"https://yongqiangg.github.io/zh/posts/tech/%E5%85%A8%E9%93%BE%E8%B7%AFid%E7%9A%84%E5%AE%9E%E7%8E%B0/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e原本单个系统的交互中，当客户端需要查找问题时，可以拿着服务端生成的request_id来咨询。\u003c/p\u003e\n\u003cp\u003e实现方式：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e定义日志切面，环绕指定基类\u003c/li\u003e\n\u003cli\u003e生成uuid，放置到日志的mdc\u003c/li\u003e\n\u003cli\u003e返回给到客户端\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在这种实现下，单个系统的问题排查没问题。但是一旦涉及多个系统的交互，一旦出问题，每个环境都要定位一遍请求，设置到问题的流转，人员的流转。\u003c/p\u003e","title":"全链路id的实现"},{"content":"讲讲MySQL索引的理解 段落2 段落3 1 code ","permalink":"https://yongqiangg.github.io/zh/posts/tech/mysql%E7%B4%A2%E5%BC%95/","summary":"\u003ch1 id=\"讲讲mysql索引的理解\"\u003e讲讲MySQL索引的理解\u003c/h1\u003e\n\u003ch2 id=\"段落2\"\u003e段落2\u003c/h2\u003e\n\u003ch3 id=\"段落3\"\u003e段落3\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecode\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"MySQL索引"}]